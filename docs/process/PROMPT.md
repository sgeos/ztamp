# Prompt Staging Area

> **Navigation**: [Process](./README.md) | [Documentation Root](../README.md)

This file is a staging area for complex human-to-AI instructions. The human pilot drafts and refines prompts here before execution.

---

# Current Prompt

## Comments

Our first goal is to establish our workflow process.

## Objectives

Review the following projects to meet the objectives:

- `/Users/bsechter/projects/blog`
- `/Users/bsechter/projects/crypto/cordial_cantina`

The blog project is newer,
and it's process was pulled in from the crypto project.

### Replicate Reference Project Process

For each project,
walk the knowledge graph
and replicate the process for this project.
Weight to blog more heavily.

#### Add and Update Process Files

Add the following files,
and update them according to the process.

- `docs/process/REVERSE_PROMPT.md`
- `docs/process/TASKLOG.md`

### Add Knowledge Graph

Draft a walkable knowledge graph for this project.
You may do research if necessary.

### Add Secret Folder to .gitignore

Add the `secret` folder to `.gitignore`.

## Context

To meet my TANF requirements,
I will need to look for a job for 30 hours per week.
The problem is that this needs to be documented on
a government form that was distributed to me as a PDF.
I also need to include a screenshot of the post-submission
receipt page after every submission.
I therefore need an automate solution for applying to jobs
and tracking application.

## Constraints

We absolutely need to work with the supplied government PDF.
This PDF should not be included in the git repo.

## Success Criteria

- Knowledge graph for project drafted.
- Process documented in knowledge graph.
- `secret` folder added to `.gitignore`.
- Questions, comments, and concerns documented in:
  `docs/process/REVERSE_PROMPT.md`
- `docs/process/TASKLOG.md` added and updated.
- Commit changes according to the process,
  with an appropriate commit message.

## Notes

I would like the tech stack to be Phoenix/Elixir with Liveview,
and a Rust NIF for number crunching and modify in place algorithms.
If custom command line tools are needed, they can be written in Rust.
